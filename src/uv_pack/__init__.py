"""
uv-pack: Bundle a locked uv environment into an offline-installable bundle.
"""

import shutil
import sys
from enum import Enum
from pathlib import Path
from typing import Iterable, Literal, Optional

import typer
from packaging.utils import parse_wheel_filename
from rich.console import Console

from ._download import (
    download_with_progress,
    find_latest_python_build,
    resolve_platform,
    session_with_retries,
)
from ._process import exit_on_error, run_cmd, progress_spinner
from ._unpack import copy_unpack_scripts

# -----------------------------------------------------------------------------
# CLI setup
# -----------------------------------------------------------------------------

app = typer.Typer(add_completion=True)
console = Console(force_terminal=True, legacy_windows=False)


def main() -> None:
    app()


# -----------------------------------------------------------------------------
# Step model
# -----------------------------------------------------------------------------

class Step(str, Enum):
    clean = "clean"
    export = "export"
    download = "download"
    build = "build"
    python = "python"
    scripts = "scripts"


PIPELINE_ORDER: tuple[Step, ...] = (
    Step.clean,
    Step.export,
    Step.download,
    Step.build,
    Step.python,
    Step.scripts,
)


def normalize_steps(steps: Optional[Iterable[Step]]) -> list[Step]:
    if not steps:
        return list(PIPELINE_ORDER)

    selected = set(steps)
    return [step for step in PIPELINE_ORDER if step in selected]


# -----------------------------------------------------------------------------
# Core operations
# -----------------------------------------------------------------------------

def export_requirements(
    *,
    requirements_file: Path,
    include_dev: bool,
    other_args: str,
) -> None:
    cmd = [
        "uv",
        "export",
        "--quiet",
        "--no-hashes",
        "--no-emit-local",
        "--format=requirements.txt",
        f"--output-file={requirements_file}",
    ]

    if not include_dev:
        cmd.append("--no-dev")

    cmd.extend(other_args.split())
    exit_on_error(run_cmd(cmd, "uv export"), console)


def export_vendor(
    *,
    requirements_file: Path,
    other_args: str,
) -> None:
    cmd = [
        "uv",
        "export",
        "--quiet",
        "--no-header",
        "--no-hashes",
        "--no-annotate",
        "--no-editable",
        "--only-emit-local",
        "--format=requirements.txt",
        f"--output-file={requirements_file}",
    ]

    cmd.extend(other_args.split())
    exit_on_error(run_cmd(cmd, "uv export"), console)

def download_third_party_wheels(
    *,
    requirements_file: Path,
    wheels_directory: Path,
    other_args: str,
) -> None:
    wheels_directory.mkdir(parents=True, exist_ok=True)

    cmd = [
        "uv", "run", "--with", "pip",
        "python", "-m", "pip", "download",
        "--prefer-binary",
        "--no-deps",
        "--disable-pip-version-check",
        "-r", str(requirements_file),
        "-d", str(wheels_directory),
    ]

    cmd.extend(other_args.split())
    exit_on_error(run_cmd(cmd, "pip download"), console)


def build_src_wheel(*, source_path: Path, out_path: Path, other_args: str) -> None:
    cmd = [
        "uv",
        "build",
        str(source_path),
        "--wheel",
        "--out-dir",
        str(out_path),
    ]

    cmd.extend(other_args.split())
    exit_on_error(run_cmd(cmd, f"uv build"), console)


def finalize_requirements(
    *,
    requirements_file: Path,
    vendor_directory: Path,
) -> None:
    vendor_pins: list[str] = []

    for wheel in vendor_directory.glob("*.whl"):
        name, version, *_ = parse_wheel_filename(wheel.name)
        vendor_pins.append(f"{name}=={version}")

    footer = "\n".join(
        [
            "# This part was autogenerated by uv-pack via the following command:",
            f"#    uv-pack {' '.join(sys.argv[1:])}",
            *sorted(set(vendor_pins)),
        ],
    )

    requirements_file.write_text(
        requirements_file.read_text(encoding="utf-8") + footer,
        encoding="utf-8",
    )


def download_latest_python_build(
    *,
    python_version: str,
    target_arch: str,
    dest_dir: Path,
    target_format: Literal["install_only", "install_only_stripped"] = "install_only_stripped",
) -> Path:
    """Resolve and download the latest python-build-standalone artifact.

    Returns the downloaded file path.
    """
    session = session_with_retries()
    url = find_latest_python_build(
        python_version=python_version,
        target_arch=target_arch,
        target_format=target_format,
        session=session,
    )
    if False:
        console.print(f"[dim]Resolved asset:[/dim] {url}")
    return download_with_progress(
        url=url,
        dest_dir=dest_dir,
        console=console,
        session=session,
    )


# -----------------------------------------------------------------------------
# Orchestration command
# -----------------------------------------------------------------------------

@app.command()
def pack(
    *,
    steps: Optional[list[Step]] = typer.Argument(
        PIPELINE_ORDER,
        help="Comma-separated pipeline steps to run",
    ),
    output_directory: Path = typer.Option(Path("./pack"), help="Path to output directory"),
    uv_export: str = typer.Option(""),
    pip_download: str = typer.Option(""),
    uv_build: str = typer.Option(""),
    system: bool = typer.Option(False),
    include_dev: bool = typer.Option(False),
    verbose: bool = typer.Option(False),
) -> None:
    """Pack a locked uv environment into an offline-installable bundle."""
    selected_steps = normalize_steps(steps)
    console.print(f"[dim]Running steps:[/dim] {[step.value for step in selected_steps]}")

    if Step.clean in selected_steps:
        shutil.rmtree(output_directory, ignore_errors=True)
        console.print(f"[green]✔ Cleaned[/green] output directory '{output_directory}'")

    output_directory.mkdir(parents=True, exist_ok=True)
    (output_directory / ".gitignore").write_text("*", encoding="utf-8")

    requirements_file = output_directory / "requirements.txt"
    wheels_dir = output_directory / "wheels"
    wheels_dir.mkdir(exist_ok=True)
    vendor_dir = output_directory / "vendor"
    vendor_dir.mkdir(exist_ok=True)
    vendor_requirements_file = vendor_dir / "requirements.txt"
    python_dir = output_directory / "python"

    if Step.export in selected_steps:
        with progress_spinner("uv export"):
            export_requirements(
                requirements_file=requirements_file,
                include_dev=include_dev,
                other_args=uv_export,
            )
            export_vendor(
                requirements_file=vendor_requirements_file,
                other_args=uv_export,
            )


    if Step.download in selected_steps:
        with progress_spinner("pip download"):
            if not requirements_file.exists():
                # TODO: Nice error message here.
                raise typer.Exit()

            download_third_party_wheels(
                requirements_file=requirements_file,
                wheels_directory=wheels_dir,
                other_args=pip_download,
            )

    if Step.build in selected_steps:
        with progress_spinner("uv build"):
            if not vendor_requirements_file.exists():
                # TODO: Nice error message here
                raise typer.Exit()

            for line in vendor_requirements_file.read_text(encoding="utf-8").splitlines():
                build_src_wheel(source_path=Path(line), out_path=vendor_dir, other_args=uv_build)

            for sdist in wheels_dir.glob("*.tar.gz"):
                build_src_wheel(source_path=sdist, out_path=wheels_dir, other_args=uv_build)
                sdist.unlink(missing_ok=True)

            finalize_requirements(
                requirements_file=requirements_file,
                vendor_directory=vendor_dir,
            )

    if Step.python in selected_steps and not system:
        platform = resolve_platform(console)
        python_version = f"{sys.version_info.major}.{sys.version_info.minor}"
        download_latest_python_build(
            python_version=python_version,
            target_arch=platform,
            dest_dir=python_dir,
        )

    if Step.scripts in selected_steps:
        copy_unpack_scripts(output_directory=output_directory)

    console.print("[green]✔ Done[/green]")
