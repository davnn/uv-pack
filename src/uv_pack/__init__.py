"""uv-pack: Bundle a locked uv environment into an offline-installable bundle.
"""

import shutil
import sys
from collections.abc import Iterable
from enum import Enum
from pathlib import Path

import typer
from packaging.utils import parse_wheel_filename

from uv_pack._export import export_requirements, export_local_requirements
from uv_pack._files import PackLayout
from uv_pack._download import download_latest_python_build
from uv_pack._process import exit_on_error, run_cmd, run_step
from uv_pack._scripts import copy_unpack_scripts
from uv_pack._logging import ConsoleError, Verbosity, console_print, set_verbosity

# -----------------------------------------------------------------------------
# CLI setup
# -----------------------------------------------------------------------------

app = typer.Typer(add_completion=True)


def main() -> None:
    app()


# -----------------------------------------------------------------------------
# Step model
# -----------------------------------------------------------------------------

class Step(str, Enum):
    clean = "clean"
    export = "export"
    download = "download"
    build = "build"
    python = "python"
    scripts = "scripts"


PIPELINE_ORDER: tuple[Step, ...] = (
    Step.clean,
    Step.export,
    Step.download,
    Step.build,
    Step.python,
    Step.scripts,
)


def normalize_steps(
        steps: Iterable[Step] | None,
        skip: Iterable[Step] | None,
    ) -> list[Step]:
    selected = set(PIPELINE_ORDER) if steps is None else set(steps)
    selected = selected.difference([] if skip is None else set(skip))
    return [step for step in PIPELINE_ORDER if step in selected]


# -----------------------------------------------------------------------------
# Core operations
# -----------------------------------------------------------------------------

def download_third_party_wheels(
    *,
    requirements_file: Path,
    wheels_directory: Path,
    other_args: str,
) -> None:
    wheels_directory.mkdir(parents=True, exist_ok=True)

    cmd = [
        "uv", "run", "--with", "pip",
        "python", "-m", "pip", "download",
        "--prefer-binary",
        "--no-deps",
        "--disable-pip-version-check",
        "-r", str(requirements_file),
        "-d", str(wheels_directory),
    ]

    cmd.extend(other_args.split())
    exit_on_error(run_cmd(cmd, "pip download"))


def build_src_wheel(*, source_path: Path, out_path: Path, other_args: str) -> None:
    cmd = [
        "uv",
        "build",
        str(source_path),
        "--wheel",
        "--out-dir",
        str(out_path),
    ]

    cmd.extend(other_args.split())
    exit_on_error(run_cmd(cmd, "uv build"))


def finalize_requirements(
    *,
    requirements_txt: Path,
    requirements_export_txt: Path,
    vendor_directory: Path,
) -> None:
    vendor_pins: list[str] = []

    for wheel in vendor_directory.glob("*.whl"):
        name, version, *_ = parse_wheel_filename(wheel.name)
        vendor_pins.append(f"{name}=={version}")

    header = "\n".join(
        [
            "# This file was autogenerated by uv-pack via the following command:",
            f"#    uv-pack {' '.join(sys.argv[1:])}",
            *sorted(set(vendor_pins)),
        ],
    )

    requirements_txt.write_text(
        header + "\n" + requirements_export_txt.read_text(encoding="utf-8"),
        encoding="utf-8",
    )


def determine_download_requirements(
    *,
    requirements_file: Path,
    wheels_directory: Path,
) -> None:
    available_wheels: list[str] = []

    for wheel in wheels_directory.glob("*.whl"):
        name, version, *_ = parse_wheel_filename(wheel.name)
        available_wheels.append(f"{name}=={version}")

    requirements_file.write_text(
        "\n".join(sorted(set(available_wheels))),
        encoding="utf-8",
    )

# -----------------------------------------------------------------------------
# Orchestration command
# -----------------------------------------------------------------------------

def _additional_cli_args(cmd_name: str) -> str:
    return f"Additional command line arguments to be provided to '{cmd_name}'"


@app.command()
def pack(
    *,
    steps: list[Step] | None = typer.Argument(
        PIPELINE_ORDER,
        help="Pipeline steps to run (multiple can be whitespace-separated)",
    ),
    skip: list[Step] | None = typer.Option(
        None,
        help="Pipeline steps to skip (can be supplied multiple times)",
    ),
    output_directory: Path = typer.Option(
        Path("./pack"),
        help="Path to output directory",
    ),
    uv_export: str = typer.Option(
        default="",
        help=_additional_cli_args("uv export"),
    ),
    pip_download: str = typer.Option(
        default="",
        help=_additional_cli_args("pip download"),
    ),
    uv_build: str = typer.Option(
        default="",
        help=_additional_cli_args("uv build"),
    ),
    include_dev: bool = typer.Option(False),
    verbose: bool = typer.Option(False),
) -> None:
    """Pack a locked uv environment into an offline-installable bundle."""
    set_verbosity(Verbosity.verbose if verbose else Verbosity.normal)
    selected_steps = normalize_steps(steps, skip)
    console_print(f"[dim]Running steps:[/dim] {[step.value for step in selected_steps]}")

    if Step.clean in selected_steps:
        with run_step("clean"):
            shutil.rmtree(output_directory, ignore_errors=True)

        console_print(
            f"[green]✔ Cleaned[/green] output directory '{output_directory}'",
            level=Verbosity.verbose
        )

    pack = PackLayout.create(output_directory=output_directory)

    if Step.export in selected_steps:
        with run_step("export"):
            export_requirements(
                requirements_file=pack.requirements_export_txt,
                include_dev=include_dev,
                other_args=uv_export,
            )
            export_local_requirements(
                requirements_file=pack.requirements_local_txt,
                other_args=uv_export,
            )
        console_print(
            f"[green]✔ Exported[/green] requirements '{pack.requirements_export_txt}'",
            level=Verbosity.verbose
        )
        console_print(
            f"[green]✔ Exported[/green] requirements '{pack.requirements_local_txt}'",
            level=Verbosity.verbose
        )

    if Step.download in selected_steps:
        _raise_requirement_txt_missing(pack.requirements_export_txt)

        with run_step("download"):
            download_third_party_wheels(
                requirements_file=pack.requirements_export_txt,
                wheels_directory=pack.wheels_dir,
                other_args=pip_download,
            )

    if Step.build in selected_steps:
        _raise_requirement_txt_missing(pack.requirements_local_txt)
        _raise_requirement_txt_missing(pack.requirements_export_txt)

        # show the progress for each package in verbose mode, otherwise a single progress report is shown
        with run_step("build", should_run=not verbose):
            for line in pack.requirements_local_txt.read_text(encoding="utf-8").splitlines():
                with run_step("build", should_run=verbose):
                    build_src_wheel(source_path=Path(line), out_path=pack.vendor_dir, other_args=uv_build)
                console_print(f"[green]✔ Built[/green] wheel: '{line}'", level=Verbosity.verbose)

            for sdist in pack.wheels_dir.glob("*.tar.gz"):
                with run_step("build", should_run=verbose):
                    build_src_wheel(source_path=sdist, out_path=pack.wheels_dir, other_args=uv_build)
                    sdist.unlink(missing_ok=True)
                console_print(f"[green]✔ Built[/green] wheel: '{sdist}'", level=Verbosity.verbose)

            finalize_requirements(
                requirements_txt=pack.requirements_txt,
                requirements_export_txt=pack.requirements_export_txt,
                vendor_directory=pack.vendor_dir,
            )
            console_print(
                f"[green]✔ Built[/green] requirements: '{pack.requirements_txt}'",
                level=Verbosity.verbose
            )


    if Step.python in selected_steps:
        pack.python_dir.mkdir(exist_ok=True)
        python_path = download_latest_python_build(
            dest_dir=pack.python_dir,
        )
        console_print(f"[green]✔ Downloaded[/green] '{python_path}'", level=Verbosity.verbose)

    if Step.scripts in selected_steps:
        with run_step("scripts"):
            copy_unpack_scripts(output_directory=output_directory)

    console_print("[green]✔ Done[/green]")


def _raise_requirement_txt_missing(path: Path) -> None:
    if not path.exists():
        msg = f"[bold red]✘ No requirements file found:[/bold red] '{path}', did you skip the 'export' step?"
        raise ConsoleError(msg)
